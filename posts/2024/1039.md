---
title: 2025.8.11 测试游记
tags: [原创]
categories: [题解]
date: 2025-8-11
description: 😠
articleGPT: 这篇文章的作者通过逐步分析，从简单的动态规划问题入手，结合 k 较小的特点，最终推导出用容斥原理和组合数学解决问题的思路，强调了预处理组合数的重要性。
---

考试时唯一想到正解的题，但因为没有预处理 $100\to 25$。

## 题面

洛谷没找到原题，挂一下题面：

> 有一个 $n$ 行 $m$ 列的棋盘，上面涂满了颜色，有黑色，也有白色，现在棋盘的左上角有一个卒，每一步可以向下或者向右移动一格，要求不能移动到黑色的格子上，问卒要走到棋盘的右下角有多少种可行的方案？答案对 $10^9+7$取模
> 
> 对于 $30\%$ 的数据保证 $1\le n,m\le 2000,1\le k \le 2000$。  
> 对于 $100\%$ 的数据保证 $1 \le n,m \le 100000, 1 \le k \le 2000$。
> 
> **输入格式**
> 
> 第一行三个数 $n$ 和 $m$ 和 $k$,表示棋盘有 $n$ 行 $m$ 列，其中棋盘上有 $k$ 个黑色的格子。
> 
> 接下来 $k$ 行，每行两个数 $x$ 和 $y$，分别表示这 $k$ 个黑色格子的坐标 位于第 $x$ 行 $y$ 列。
> 
> **输出格式**
> 
> 一个整数，表示方案数。

第一眼：这不 DP 入门题吗？

第二眼：$1 \le n,m \le 100000$ 啊，那没事了。

很明显 $O(nm)$ 只能拿 $30pt$，所以我们需要找更优解，可以发现 $k$ 非常小，所以我们从 $k$ 开始思考。

## 思路

我们可以运用一些神秘 Excel 科技来辅助思考。

![](https://cdn.luogu.com.cn/upload/image_hosting/vr7dgdcv.png)

这是在没有黑格时的情况，转移方程是 $f_{i,j}=f_{i-1,j}+f_{i,j-1}$。但我们前面已经知道了，这种方法显然不可取。

我们将 $(3,3)$ 去掉找找规律。

![](https://cdn.luogu.com.cn/upload/image_hosting/kuf6rqh9.png)

可以发现，$(3,3)$ 右下方的矩阵的各个元素数值都有减少，我们再标注一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/w83v54qo.png)

~~这不是没啥规律吗~~。别急，仔细看一下，可以发现减少的值 $\div 6$ 正好是一个杨辉三角。

走到这一步想必大家都懂了，就是通过枚举每一个被挖掉的格子来计算对 $(n,m)$ 的影响。

**但是**，还有一种情况，一个黑色格子会影响其他的黑色格子，例如下面：

![](https://cdn.luogu.com.cn/upload/image_hosting/b4t2m60u.png)

位于 $(3,3)$ 的格子会影响到 $(4,4)$ 的格子，从而使 (4,4) 对后面的影响产生变化，用 OI 的语言说就是存在后效性，为了消除后效性我们要在处理之前进行排序。

那有人就要问了：那这样枚举子矩阵还是会超时啊。

不是哥们我也没说要暴力枚举整个子矩阵啊，我们只需要枚举黑色格子计算最终影响即可。

我们假设 $(x,y)$ 为黑色格子，设 $f_{i,j}$ 为其在计算其他黑色格子产生的影响后的数值，那其对 $(n,m)$ 的影响为 $C_{n+m-x-y}^{m-y}$，这一点手推一下即可得出。

组合数的计算要用逆元，不会的建议自行 bdfs，**千万要记得预处理**，否则就会像我一样 T 飞，速度甚至跑不过暴力。

## 代码

码风比较抽象，还请各位见谅。

```cpp
#include<bits/stdc++.h>
#define int long long
#define pii pair<int,int>
#ifdef __linux__
#define getchar getchar_unlocked
#define putchar putchar_unlocked
#else
#define getchar _getchar_nolock
#define putchar _putchar_nolock
#endif
using namespace std;
namespace FastIO{
	void read(){}
	template<class T1,class...T2>inline void read(T1&x,T2&...oth){
		bool pd=0;x=0;char ch=getchar();
		while(!isdigit(ch)){pd|=ch=='-';ch=getchar();}
		while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
		x=pd?-x:x;
		read(oth...);
	}
	template<class T>void _write(T x){
		if(x<0){putchar('-');x=-x;}
		if(x>9)_write(x/10);
		putchar(x%10^48);
	}
	void write(){}
	template<class T1,class...T2>inline void write(T1 x,T2...oth){
		_write(x);putchar(' ');write(oth...);
	}
	inline void endline(){putchar('\n');}
}
using namespace FastIO;
const int mod=1e9+7,N=5e5+5;
int n,m,k;
pii a[2003];
int f[2003],fact[N+5],invF[N+5];
int mi(int a,int b){
	int res=1;
	while(b){
		if(b&1)res=res*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return res;
}
void pre_C(int mx){
	fact[0]=1;
	for(int i=1;i<=mx;i++)fact[i]=fact[i-1]*i%mod;
	invF[mx]=mi(fact[mx],mod-2);
	for(int i=mx-1;i>=0;i--)invF[i]=invF[i+1]*(i+1)%mod;
}
int C(int a,int b){
	if(b<0||b>a)return 0;
	return fact[a]*invF[b]%mod*invF[a-b]%mod;
}
bool cmp(pii a,pii b){
	if(a.first!=b.first)return a.first<b.first;
	return a.second<b.second;
}
int fun(int x,int y){
	return C(x+y-2,y-1);
}
signed main(){
	read(n,m,k);
	pre_C(n+m-2);
	for(int i=1;i<=k;i++){
		read(a[i].first,a[i].second);
		if((a[i].first==1&&a[i].second==1)||(a[i].first==n&&a[i].second==m)){
			cout<<0;
			return 0;
		}
	}
	sort(a+1,a+k+1,cmp);
	for(int i=1;i<=k;i++)f[i]=fun(a[i].first,a[i].second);
	for(int i=1;i<=k;i++){
		int x=a[i].first,y=a[i].second;
		for(int j=1;j<=k;j++)
			if(a[j].first>=x&&a[j].second>=y&&i!=j)
				f[j]=(f[j]-fun(a[j].first-x+1,a[j].second-y+1)*f[i]%mod+mod)%mod;
	}
	int ans=fun(n,m);
	for(int i=1;i<=k;i++){
		int x=a[i].first,y=a[i].second;
		ans=(ans-fun(n-x+1,m-y+1)*f[i]%mod+mod)%mod;
	}
	cout<<ans;
	return 0;
}
```

终于写完了……

## 致谢名单

- [zxx（并非真名）](https://www.luogu.com.cn/user/1167457)：提供表格。
